# the first X-Klaim program

nodes
hello_world :: {}
  class "Klava.NetNode"
  begin
    print "Hello World!"
  end
endnodes

# the first X-Klaim program

nodes
hello_world :: {}
  class "Klava.NetNode"
  begin
    print "Hello World!"
  end
endnodes

/*
  File HelloWorld.java

  Generated by xklaim compiler
*/

import java.io.* ;
import Klava.* ;

class __hello_world_1 extends KlavaProcess {
  // variables
  // used definition names

  public __hello_world_1() {}

  public void execute() throws KlavaException {
    Print( new KString( "Hello World!" ) ) ;
  }
}
// main class
public class HelloWorld {
  static public void main( String args[] ) throws IOException, KlavaException {
    KlavaApplication app = new KlavaApplication();
    NetNode hello_world = new Klava.NetNode( "hello_world", 9999 );
    app.addNode(hello_world) ;
    hello_world.addProcess( new __hello_world_1() ) ;
    app.startNodes();
    app.waitForNodesAndTerminate();
  }
}

ClientNode o Net?

node class=Net address="..."

node class=ClientNode address="..." {
	login
}

oppure come era prima

net locality="..." {
	node ...
	node ...
}

	protected def reassignThisType(ITreeAppendable b, JvmDeclaredType declaredType) {
		if (b.hasObject('this')) {
			val element = b.getObject('this')
			if (element instanceof JvmDeclaredType) {
				if (element.local) {
					b.declareVariable(element, '')
				} else {
					val proposedName = element.simpleName+'.this'
					b.declareVariable(element, proposedName)
				}
			}
		}
		if (declaredType !== null)
			b.declareVariable(declaredType, 'this');
	}

	protected String getReferenceName(XExpression expr, ITreeAppendable b) {
		if (b.hasName(expr))
			return b.getName(expr);
		if (expr instanceof XFeatureCall) {
			XFeatureCall featureCall = (XFeatureCall) expr;
			if (b.hasName(featureCall.getFeature()))
				return b.getName(featureCall.getFeature());
		}
		return null;
	}

final variables cannot be used when the operation is used as a boolean operation

package foo
proc TestProcess(String s) {
	if (in_nb(var Integer i, s)@self && !in_nb(var String l)@self) {
		println(l + i)
	} else {
		val res = (l + i)
	}
}

INNER PROCESSES VARIABLE BINDINGS:

public class HelloRemoveEvalProcNet extends LogicalNet {
  public static class Reader extends ClientNode {
    private static class ReaderProcess extends KlavaProcess {
      @Override
      public void executeProcess() {
        final LogicalLocality writerLoc = new LogicalLocality("writer");
        KlavaProcess _Proc = new KlavaProcess() {
          LogicalLocality writerLoc;
          private KlavaProcess _initFields(LogicalLocality writerLoc) {
            this.writerLoc = writerLoc;
            return this;
          }
          @Override public void executeProcess() {
            {
              Locality _physical = ReaderProcess.this.getPhysical(writerLoc);
              String _plus = ("executing at " + _physical);
              InputOutput.<String>println(_plus);
              String s = null;
              Tuple _Tuple = new Tuple(new Object[] {String.class});
              in(_Tuple, ReaderProcess.this.self);
              s = (String) _Tuple.getItem(0);
              InputOutput.<String>println(s);
            }
          }
        }._initFields(writerLoc);
        eval(_Proc, writerLoc);
      }
    }

Locality _physical = ReaderProcess.this.getPhysical(writerLoc);

this is wrong: it should be

Locality _physical = this.getPhysical(writerLoc);

otherwise in a mobile process we refer the old enclosing object which does
not exist anymore.

DONE

EVAL ARGUMENTS

- standard expressions considered as inner processes
- if it's already a KlavaProcess then use it as it is

in(var KlavaProcess P)@self
println("Received proc: " + P)
eval(P)@self

DONE

Due to the anonymous inner class in node coordinator we get (for inner processes)

klava.KlavaException: java.io.NotSerializableException: xklaim.examples.helloremoteeval.HelloRemoveEvalProcNet$Reader$ReaderProcess
	at klava.topology.KlavaNode.tupleOperation(KlavaNode.java:1152)
	at klava.topology.KlavaNode.tupleOperation(KlavaNode.java:1072)
	at klava.topology.KlavaNode.eval(KlavaNode.java:684)
	at klava.topology.KlavaNodeProcessProxy.eval(KlavaNodeProcessProxy.java:160)
	at klava.topology.KlavaNodeCoordinator.eval(KlavaNodeCoordinator.java:213)
	at xklaim.examples.helloremoteeval.HelloRemoveEvalProcNet$Reader$ReaderProcess.executeProcess(HelloRemoveEvalProcNet.java:40)
	at klava.topology.KlavaNodeCoordinator.execute(KlavaNodeCoordinator.java:69)
	at org.mikado.imc.topology.NodeCoordinator.run(NodeCoordinator.java:98)
Caused by: java.io.NotSerializableException: xklaim.examples.helloremoteeval.HelloRemoveEvalProcNet$Reader$ReaderProcess
	at klava.proto.TupleState.enter(TupleState.java:148)
	at klava.proto.TupleOpState.writePacket(TupleOpState.java:220)
	at klava.proto.TupleOpState.writePacket(TupleOpState.java:166)
	at klava.proto.TupleOpState.enter(TupleOpState.java:122)
	at klava.topology.KlavaNode.tupleOperation(KlavaNode.java:1143)
	... 7 more
	
Possible solution:

preprocess inner processes in the inferrer as static private nested classes and
also associate the XExpression as the body of the inferred "executeProcess" method

No it does not work: make KlavaNodeCoordinator serializable DONE

net Net physical {

	node L1 [...] {...}
	node L2 [...] {...}

}

automatically defines a field in the Net class of type LogicalLocality

after starting the nodes, in the net, also modifies their environments as specified in the DSL

... node L1 [ next -> L2 ]

"next" defines a LogicalLocality in the node class and L2 must be a Locality (e.g., reference to an existing one)

the compiled code will generate

addToNodeEnvironment(new LogicalLocality("next"), getPhysical(L2))

DONE
