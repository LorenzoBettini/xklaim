/*
 * generated by Xtext 2.16.0
 */
package xklaim.tests

import com.google.inject.Inject
import org.eclipse.xtext.testing.InjectWith
import org.eclipse.xtext.testing.XtextRunner
import org.eclipse.xtext.testing.util.ParseHelper
import org.junit.Assert
import org.junit.Test
import org.junit.runner.RunWith
import xklaim.xklaim.XklaimModel
import org.junit.Rule
import org.eclipse.xtext.xbase.testing.TemporaryFolder
import org.eclipse.xtext.xbase.testing.CompilationTestHelper
import org.eclipse.xtext.xbase.testing.CompilationTestHelper.Result
import org.eclipse.xtext.diagnostics.Severity
import com.google.common.base.Joiner

import static extension org.junit.Assert.*

@RunWith(XtextRunner)
@InjectWith(XklaimInjectorProvider)
class XklaimCompilerTest {
	@Inject ParseHelper<XklaimModel> parseHelper
	@Rule @Inject public TemporaryFolder temporaryFolder
	@Inject extension CompilationTestHelper

	@Test
	def void testEmptyProgram() {
		'''
		package foo
		node TestNode {
			println("Hello")
		}
		'''.checkCompilation(
			"foo.MyFile" ->
			'''
			package foo;
			
			import foo.TestNode;
			
			@SuppressWarnings("all")
			public class MyFile {
			  public static void main(final String[] args) throws Exception {
			    TestNode testNode = new TestNode();
			    testNode.addMainProcess();
			  }
			}
			''',
			"foo.TestNode" ->
			'''
			package foo;
			
			import klava.topology.KlavaNode;
			import klava.topology.KlavaProcess;
			import org.eclipse.xtext.xbase.lib.InputOutput;
			import org.mikado.imc.common.IMCException;
			
			@SuppressWarnings("all")
			public class TestNode extends KlavaNode {
			  public void addMainProcess() throws IMCException {
			    addNodeProcess(new TestNode.TestNodeProcess());
			  }
			  
			  private static class TestNodeProcess extends KlavaProcess {
			    @Override
			    public void executeProcess() {
			      InputOutput.<String>println("Hello");
			    }
			  }
			}
			'''
		)
	}

	def private checkCompilation(CharSequence input, CharSequence expectedGeneratedJava) {
		checkCompilation(input, expectedGeneratedJava, true)
	}

	def private checkCompilation(CharSequence input, CharSequence expectedGeneratedJava, boolean checkValidationErrors) {
		input.compile[
			if (checkValidationErrors) {
				assertNoValidationErrors
			}
			if (expectedGeneratedJava !== null) {
				assertGeneratedJavaCode(expectedGeneratedJava)
			}
			if (checkValidationErrors) {
				assertGeneratedJavaCodeCompiles
			}
		]
		println("a" -> "b")
	}

	def private checkCompilation(CharSequence input, Pair<CharSequence, CharSequence>... expectations) {
		input.compile[
			assertNoValidationErrors
			for (exp : expectations) {
				exp.value.toString.assertEquals(getGeneratedCode(exp.key.toString))
			}
			assertGeneratedJavaCodeCompiles
		]
	}

	private def assertNoValidationErrors(Result it) {
		val allErrors = getErrorsAndWarnings.filter[severity == Severity.ERROR]
		if (!allErrors.empty) {
			throw new IllegalStateException("One or more resources contained errors : "+
				Joiner.on(',').join(allErrors)
			);
		}
	}

	def private assertGeneratedJavaCode(CompilationTestHelper.Result r, CharSequence expected) {
		expected.toString.assertEquals(r.singleGeneratedCode)
	}

	def private assertGeneratedJavaCodeCompiles(CompilationTestHelper.Result r) {
		r.compiledClass // check Java compilation succeeds
	}
}
