/*
 * generated by Xtext 2.16.0
 */
package xklaim.tests

import com.google.inject.Inject
import org.eclipse.emf.ecore.EObject
import org.eclipse.xtext.diagnostics.Severity
import org.eclipse.xtext.testing.InjectWith
import org.eclipse.xtext.testing.XtextRunner
import org.eclipse.xtext.testing.util.ParseHelper
import org.eclipse.xtext.testing.validation.ValidationTestHelper
import org.junit.Test
import org.junit.runner.RunWith
import xklaim.xklaim.XklaimModel

import static extension org.junit.Assert.*

@RunWith(XtextRunner)
@InjectWith(XklaimInjectorProvider)
class XklaimValidatorTest {
	@Inject extension ParseHelper<XklaimModel> parseHelper
	@Inject extension ValidationTestHelper validationTestHelper

	@Test
	def void testValidSelfLocality() {
		'''
			proc TestProc() {
				out("hi")@self
			}
		'''.parse.assertNoIssues
	}

	@Test
	def void testValidLocality() {
		'''
			import klava.Locality
			import klava.PhysicalLocality
			import klava.LogicalLocality
			
			proc TestProc(Locality l1, PhysicalLocality l2, LogicalLocality l3) {
				out("hi")@l1
				out("hi")@l2
				out("hi")@l3
			}
		'''.parse.assertNoIssues
	}

	@Test
	def void testInvalidLocality() {
		'''
			proc TestProc(int i) {
				out("hi")@i
			}
		'''.parse.assertErrorsAsStrings("Type mismatch: cannot convert from int to Locality")
	}

	@Test
	def void testCanAccessFormalTupleFields() {
		'''
		package foo
		proc TestProcess(String s) {
			in(var Integer i, s)@self
			println(i)
		}
		'''.parse.assertNoIssues
	}

	@Test
	def void testFormalTupleFieldMustHaveAType() {
		'''
		package foo
		proc TestProcess(String s) {
			in(var i, s)@self
		}
		'''.parse.assertErrorsAsStrings("Type must be specified")
	}

	@Test
	def void testFormalTupleFieldCannotHaveInitialization() {
		'''
		package foo
		proc TestProcess(String s) {
			in(var Integer i = 10, s)@self
		}
		'''.parse.assertErrorsAsStrings("Formal field must not be initialized")
	}

	@Test
	def void testCanUseValForFormalTupleFields() {
		'''
		package foo
		proc TestProcess(String s) {
			in(val Integer i, s)@self
			println(i)
		}
		'''.parse.assertNoIssues
	}

	@Test
	def void testNonBlockingOperationAsStatement() {
		'''
		package foo
		proc TestProcess(String s) {
			in_nb(val Integer i, s)@self
			read_nb(val Integer x, s)@self
			println(i)
		}
		'''.parse.assertNoIssues
	}

	@Test
	def void testNonBlockingOperationAsBooleanExpressionInIfStatement() {
		'''
		package foo
		proc TestProcess(String s) {
			if (in_nb(val Integer i, s)@self && !in_nb(val String l)@self) {
				println(l + i)
			} else {
				println(l + i)
			}
			if (read_nb(val Integer i, s)@self) {
				println(i)
			} else {
				println(i)
			}
		}
		'''.parse.assertNoIssues
	}

	@Test
	def void testTimeoutOperationAsBooleanExpressionInIfStatement() {
		'''
		package foo
		proc TestProcess(String s) {
			if ((in(val Integer i, s)@self within 1000) && (!in(val String l)@self within 1000)) {
				println(l + i)
			} else {
				println(l + i)
			}
			if (read(val Integer i, s)@self within 1000) {
				println(i)
			} else {
				println(i)
			}
		}
		'''.parse.assertNoIssues
	}

	@Test
	def void testTimeoutAsLong() {
		'''
		package foo
		proc TestProcess(String s) {
			in(val Integer i, s)@self within 1000
			in(val Integer i2, s)@self within "foo"
		}
		'''.parse.assertErrorsAsStrings("Type mismatch: cannot convert from String to long")
	}

	@Test
	def void testNonBlockingInOperationAsBooleanExpressionInWhileStatementWithFinalVariable() {
		'''
		package foo
		proc TestProcess(String s) {
			while (in_nb(val Integer i, s)@self) {
				println(i)
			}
		}
		'''.parse.assertErrorsAsStrings("use 'var' instead of 'val' for formal field in loop's expression")
	}

	@Test
	def void testNonBlockingInOperationAsBooleanExpressionInBasicForLoopWithFinalVariable() {
		'''
		package foo
		proc TestProcess(String s) {
			for (;in_nb(val Integer i, s)@self;) {
				println(i)
			}
		}
		'''.parse.assertErrorsAsStrings("use 'var' instead of 'val' for formal field in loop's expression")
	}

	@Test
	def void testNonBlockingInOperationAsBooleanExpressionInWhileStatement() {
		'''
		package foo
		proc TestProcess(String s) {
			while (in_nb(var Integer i, s)@self) {
				println(i)
			}
		}
		'''.parse.assertNoIssues
	}

	@Test
	def void testNonBlockingInOperationAsBooleanExpressionInDoWhileStatement() {
		'''
		package foo
		proc TestProcess(String s) {
			do {
				println()
			} while (in_nb(val Integer i, s)@self)
		}
		'''.parse.assertNoIssues
	}

	@Test
	def void testFormalFieldsInNonBlockingInOperationAsBooleanExpressionAreNotVisibleOutside() {
		'''
		package foo
		proc TestProcess(String s) {
			if (in_nb(val Integer i, s)@self && !in_nb(val String l)@self) {
				
			}
			println(l + i)
		}
		'''.parse.assertErrorsAsStrings(
			'''
			The method or field i is undefined
			The method or field l is undefined
			'''
		)
	}

	@Test
	def void testDuplicateFormalFieldsInXklaimOperationInBooleanExpression() {
		'''
		package foo
		proc TestProcess(String s) {
			if (in_nb(var Integer i, s)@self && !in_nb(var String i)@self) {
				
			}
		}
		'''.parse.assertErrorsAsStrings(
			'''
			Duplicate local variable i
			'''
		)
	}

	@Test
	def void testDuplicateFormalFieldsInXklaimOperationAfterIf() {
		'''
		package foo
		proc TestProcess(String s) {
			if (in_nb(var Integer i, s)@self) {
				
			}
			in(var String i)@self
		}
		'''.parse.assertNoErrors
	}

	@Test
	def void testDuplicateFormalFieldsInXklaimOperation() {
		'''
		package foo
		proc TestProcess(String s) {
			in(var Integer i, s)@self
			in(var String i)@self
		}
		'''.parse.assertErrorsAsStrings(
			'''
			Duplicate local variable i
			'''
		)
	}

	@Test
	def void testInlineProcInOperations() {
		'''
		package foo
		
		proc TestProcess(String s) {
			var nonFinalVar = "a"
			val finalVar = "b"
			out(proc {
				var myLocalVar = "c"
				println(finalVar + nonFinalVar)
				println(s + finalVar + nonFinalVar + myLocalVar + self)
			},
			proc println(finalVar + nonFinalVar),
			s + finalVar + nonFinalVar)@self
		}
		'''.parse.assertNoIssues
	}

	@Test
	def void testInlineProcInVariable() {
		'''
		package foo
		
		proc TestProcess(String s) {
			var nonFinalVar = "a"
			val finalVar = "b"
			val P = proc {
				var myLocalVar = "c"
				println(finalVar + nonFinalVar)
				println(s + finalVar + nonFinalVar + myLocalVar + self)
			}
			out(P)@self
		}
		'''.parse.assertNoIssues
	}

	@Test
	def void testValidEvalOperation() {
		'''
		package foo
		
		proc P(String s) {
			
		}
		
		proc TestProcess(String s) {
			eval(new P("test"))@self
			eval(proc println("test"))@self
		}
		'''.parse.assertNoIssues
	}

	@Test
	def void testEvalOperationWithoutExplicitInnerProc() {
		'''
		package foo
		
		proc P(String s) {
			
		}
		
		proc TestProcess(String s) {
			eval("test")@self
		}
		'''.parse.assertNoIssues
	}

	@Test
	def void testCanAccessImplicitNetLogicalLocalities() {
		'''
		package foo
		net TestNet physical "tcp-127.0.0.1:9999" {
			node TestNode {
				println("Hello from " + TestNode)
			}
			node TestNodeWithLogLoc logical "foo" {
				println("Hello from " + foo)
			}
		}
		'''.parse.assertNoIssues
	}

	@Test
	def void testNetNodeWithEnvironment() {
		'''
		package foo
		net TestNet physical "tcp-127.0.0.1:9999" {
			node TestNodeWithEmptyEnvironment [] {
				println("Hello from " + TestNodeWithEmptyEnvironment)
			}
			node TestNodeWithEnvironment [next -> foo] {
				println("Hello from " + TestNodeWithEnvironment)
			}
			node TestNodeWithLogLoc logical "foo" {
				println("Hello from " + foo)
			}
		}
		'''.parse.assertNoIssues
	}

	@Test
	def void testNetNodeWithInvalidEnvironmentMappingToNonLocality() {
		'''
		package foo
		net TestNet physical "tcp-127.0.0.1:9999" {
			node TestNodeWithEnvironment [next -> "wrong"] {
				println("Hello from " + TestNodeWithEnvironment)
			}
		}
		'''.parse.assertErrorsAsStrings("Type mismatch: cannot convert from String to Locality")
	}

	@Test
	def void testCanAccessXklaimRuntimeUtilityMethods() {
		'''
		package foo
		proc Test() {
			val ll = logloc("test_log_loc")
			val pl = phyloc("test_phy_loc")
			println("" + ll + pl)
		}
		'''.parse.assertNoIssues
	}

	@Test
	def void testCanAccessKlavaClassesWithoutImport() {
		'''
		package foo
		proc Test() {
			val e = new Environment()
			val ee = new Environment.EnvironmentEntry(null, null)
			val KlavaProcess p = null
			println("" + e + ee + p)
		}
		'''.parse.assertNoIssues
	}

	def private assertErrorsAsStrings(EObject o, CharSequence expected) {
		expected.toString.trim.assertEquals(
			o.validate.filter[severity == Severity.ERROR].map[message].sort.join(System.lineSeparator))
	}
}
